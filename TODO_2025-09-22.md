# TODO / Findings – 2025-09-22

## Context
Historical note (deprecated): legacy per-user allow‑list code formerly under `plugins/users_books` was migrated into the integrated `app/` layer. This file retains prior investigation details for context only.

## Current Behavior
- Plugin loads after upstream via `entrypoint/entrypoint_mainwrap.py`.
- `filter_hook.attach_filter_hook()` installs a global `before_compile` listener on `Select`.
- Filtering predicate is never injected; users still see all books.

## Root Cause
`_import_books_model()` in `filter_hook.py` only attempts `from cps.models import Books`.
- Upstream defines `Books` model in `cps.db` (`class Books(Base): __tablename__='books'`).
- Import fails silently; `_BooksModel` stays `None`; `_select_involves_books()` always returns False.
- Listener exits early without modifying statements.

## Immediate Non-Core Fix (Recommended First)
Enhance `_import_books_model()` resolution order:
1. `from cps.db import Books`
2. Fallback: `from cps import models as maybe_models; getattr(maybe_models, 'Books', None)` (future-proofing)
3. Heuristic scan: iterate loaded modules for an attribute `Books` with `__tablename__ == 'books'`.

Once resolved, existing logic (admin bypass, empty allow‑list handling, size cap) should start applying.

## Optional Improvements (Still No Core Change)
- Provide structured context dict in entrypoint after upstream init and pass as second arg `cw=` to `init_app(app, cw=ctx)` (backward compatible; plugin can ignore if None).
- Add plugin registry (`plugins/runtime/registry.py`) for metadata & diagnostics.
- Simplify nav link injection (decide to keep only loader wrapper after confirming reliability; keep after_request behind env flag if needed).

## Core Change Options (Require Explicit Approval per Global Rule 0)
All options aim to expose a deterministic in-core plugin init point and/or context. Keep changes minimal and clearly commented.

### Option A: Post-Create Hook Loop
Add near end of `cps/__init__.py:create_app()` before `return app`:
```python
# Plugin post-create hooks (local extension point)
for fn in getattr(app, "_cw_post_create_hooks", []):
    try:
        fn(app)
    except Exception:
        log.exception("Post-create hook failed")
```
Then external code (entrypoint) appends a function to `app._cw_post_create_hooks` before or after calling `create_app()`. Context still built outside.

### Option B: In-Core Plugin Loader
Inside `create_app()` after services initialized:
- Parse `CALIBRE_WEB_PLUGINS`.
- Build context dict (session, models, config, limiter, etc.).
- Import each plugin; attempt `init_app(app, cw=ctx)`; fallback to `init_app(app)`.
Pros: unified lifecycle. Cons: more upstream divergence.

### Option C: Context Exporter (Minimal)
Add single function in core:
```python
def get_runtime_context():
    return {
        "app": app,
        "db_session": ub.session,
        "user_model": getattr(ub, "User", None),
        "books_model": getattr(sys.modules.get("cps.db"), "Books", None),
        "config": config,
        "calibre_db": calibre_db,
        "login_manager": lm,
        "limiter": limiter,
    }
```
Entry point still loads plugins; passes `cw=context`. Very low maintenance cost.

### Option D: Hybrid (A + C)
Combine Option A hook loop with Option C context helper; register one closure that loads all plugins using the exported context.

## Comparison Summary
| Goal | A | B | C | D |
|------|---|---|---|---|
| Minimal core diff | ✓ | ✗ | ✓ | ✓ (slightly more than A) |
| Deterministic ordering | ✓ | ✓ | ✓ (external) | ✓ |
| Encapsulate env parsing in core | ✗ | ✓ | ✗ | ✗ |
| Lowest rebase friction | ✓ | ✗ | ✓ | ✓ |
| Provides structured context | Indirect (external) | ✓ | ✓ | ✓ |

## Recommendation
1. Implement non-core fix to `_import_books_model()` first (fast path; validates filter logic). 
2. If structured context is still desirable, adopt Option C (exporter) only. 
3. Revisit A/D later if multiple plugins emerge needing unified lifecycle or you want a formal extension point.

## Potential Follow-Up Tasks
- [ ] Patch `_import_books_model()` to resolve `Books` from `cps.db`.
- [ ] Add optional `cw` parameter to `init_app(app, cw=None)` (no behavioral change yet).
- [ ] (Optional) Implement `get_runtime_context()` in core (if approved) + update entrypoint to pass it.
- [ ] Add lightweight plugin registry for diagnostics.
- [ ] Evaluate removing after_request nav injection once loader path proven.
- [ ] Add unit test: simulate non-admin user with empty allow list => zero rows when `USERS_BOOKS_ENFORCE_EMPTY=true`.

## Risk Notes
- Core edits introduce rebase overhead against upstream Calibre-Web; avoid unless clear ROI.
- Heuristic module scanning should stay last in order to minimize accidental matches.
- Ensure any context dict doesn’t include sensitive secrets not already accessible to plugins.

## Verification Plan After Fix
1. Create non-admin user (no allow entries) => expect empty catalog page (or forced FALSE predicate) if strict empty mode on.
2. Add mapping via admin API `POST /plugin/users_books/admin/<uid>/filters {"book_id": X}`.
3. Reload catalog as that user => now see only that book.
4. Confirm admin user still sees full catalog (bypass).
5. Temporarily raise `USERS_BOOKS_MAX_IDS_IN_CLAUSE` low (e.g., 1) and add 2 entries to verify fail-open behavior logs warning and shows >1 book (expected when threshold exceeded).

## Notes
This file documents analysis only; no code changes yet were applied in accordance with the request.

---
Generated on 2025-09-22.
